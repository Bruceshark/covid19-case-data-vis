package comp3111.covid;

import comp3111.covid.controller.ChartController;
import comp3111.covid.controller.TableController;
import comp3111.covid.core.*;
import comp3111.covid.ui.CheckListViewWithList;
import javafx.collections.ObservableList;
import javafx.embed.swing.SwingFXUtils;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.SnapshotParameters;
import javafx.scene.chart.LineChart;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.XYChart;
import javafx.scene.control.*;
import javafx.scene.control.Label;
import javafx.scene.control.Button;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.image.WritableImage;
import javafx.scene.transform.Transform;
import javafx.stage.FileChooser;
import javafx.util.Callback;
import javafx.util.StringConverter;

import javax.imageio.ImageIO;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;

import java.time.LocalDate;
import java.util.*;

/**
 * Building on the sample skeleton for 'ui.fxml' Controller Class generated by SceneBuilder
 */
public class Controller {

    private static CSVFileOperator fileOperator;

    @FXML
    private Tab tabTaskZero;

    @FXML
    private TextField textfieldISO;

    @FXML
    private Button buttonConfirmedDeaths;

    @FXML
    private TextField textfieldDataset;

    @FXML
    private Button buttonRateOfVaccination;

    @FXML
    private Button buttonConfirmedCases;

    @FXML
    private Tab tabReport1;

    @FXML
    private Tab tabReport2;

    @FXML
    private Tab tabReport3;

    @FXML
    private Tab tabApp1;

    @FXML
    private Tab tabApp2;

    @FXML
    private Tab tabApp3;

    @FXML
    private TextArea textAreaConsole;




    @FXML
    private Button doConfirmTableA;




//    @FXML
//    private LineChart<Number, Number> chartA;

//    @FXML
//    private NumberAxis chartAX;
//
//    @FXML
//    private NumberAxis chartAY;
//
//    @FXML
//    private TextField chartAText;
//
//    @FXML
//    private CheckListViewWithList<String> chartACountryList;
//
//    @FXML
//    private Button chartAButton;
//
//    @FXML
//    private DatePicker chartAStartDatePicker;
//
//    @FXML
//    private DatePicker chartAEndDatePicker;

//
//    @FXML
//    public LineChart<Number, Number> chartB;
//
//    @FXML
//    private NumberAxis chartBX;
//
//    @FXML
//    private NumberAxis chartBY;
//
//    @FXML
//    private TextField chartBText;
//
//    @FXML
//    private CheckListViewWithList<String> chartBCountryList;
//
//    @FXML
//    private Button chartBButton;
//
//    @FXML
//    private DatePicker chartBStartDatePicker;
//
//    @FXML
//    private DatePicker chartBEndDatePicker;
//
//    @FXML
//    private LineChart<Number, Number> chartC;
//
//    @FXML
//    private NumberAxis chartCX;
//
//    @FXML
//    private NumberAxis chartCY;
//
//    @FXML
//    private TextField chartCText;
//
//    @FXML
//    private CheckListViewWithList<String> chartCCountryList;
//
//
//    @FXML
//    private DatePicker chartCStartDatePicker;
//
//    @FXML
//    private DatePicker chartCEndDatePicker;




    @FXML
    TabPane mainTabPane;

    @FXML
    ChartController chartAController;

    @FXML
    ChartController chartBController;

    @FXML
    ChartController chartCController;

    @FXML
    TableController tableAController;
    @FXML
    TableController tableBController;

    @FXML
    TableController tableCController;
    public void initialize() {
//        disable the text input of the date picker, but not make it gray


//        final Callback<DatePicker, DateCell> tableCCellFactory =
//                new Callback<DatePicker, DateCell>() {
//                    @Override
//                    public DateCell call(final DatePicker datePicker) {
//                        return new DateCell() {
//                            @Override
//                            public void updateItem(LocalDate item, boolean empty) {
//                                super.updateItem(item, empty);
//
//                                if (item.isBefore(
//                                        utils.dateToLocalDate(fileOperator.getMinimumDate()))
//                                ) {
//                                    setDisable(true);
//                                    setStyle("-fx-background-color: #ffc0cb;");
//                                }
//                                if (item.isAfter(utils.dateToLocalDate(fileOperator.getMaximumDate()))) {
//                                    setDisable((true));
//                                    setStyle("-fx-background-color: #ffc0cb;");
//                                }
//                            }
//                        };
//                    }
//                };



//        tableCText.textProperty().addListener((observable, oldValue, newValue) -> {
//            //String countryName = tableAText.getText();
//            List<String> countryNames = fileOperator.searchCountry(newValue);
//            tableCCountryList.update(countryNames);
//            tableCText.requestFocus();
//        });

        List<String> countryNames = fileOperator.getAllCountries();


//        tableCCountryList.update(countryNames);

        //chartB.setAnimated(false);

//
//        chartBStartDatePicker.getEditor().setDisable(true);
//        chartBStartDatePicker.getEditor().setOpacity(1);
//        chartBStartDatePicker.setValue(utils.dateToLocalDate(fileOperator.getMinimumDate()));
//        chartBEndDatePicker.getEditor().setDisable(true);
//        chartBEndDatePicker.getEditor().setOpacity(1);
//        chartBEndDatePicker.setValue(utils.dateToLocalDate(fileOperator.getMaximumDate()));

//        final Callback<DatePicker, DateCell> tableACellFactoryEnd =
//                new Callback<DatePicker, DateCell>() {
//                    @Override
//                    public DateCell call(final DatePicker datePicker) {
//                        return new DateCell() {
//                            @Override
//                            public void updateItem(LocalDate item, boolean empty) {
//                                super.updateItem(item, empty);
//
//                                if (item.isBefore(
//                                        chartAStartDatePicker.getValue().plusDays(1))
//                                ) {
//                                    setDisable(true);
//                                    setStyle("-fx-background-color: #ffc0cb;");
//                                }
//                                if (item.isAfter(utils.dateToLocalDate(fileOperator.getMaximumDate()))) {
//                                    setDisable((true));
//                                    setStyle("-fx-background-color: #ffc0cb;");
//                                }
//                            }
//                        };
//                    }
//                };
        final Callback<DatePicker, DateCell> tableACellFactoryStart =
                new Callback<DatePicker, DateCell>() {
                    @Override
                    public DateCell call(final DatePicker datePicker) {
                        return new DateCell() {
                            @Override
                            public void updateItem(LocalDate item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item.isBefore(
                                        utils.dateToLocalDate(fileOperator.getMinimumDate()))
                                ) {
                                    setDisable(true);
                                    setStyle("-fx-background-color: #ffc0cb;");
                                }
                                if (item.isAfter(utils.dateToLocalDate(fileOperator.getMaximumDate()).minusDays(1))) {
                                    setDisable((true));
                                    setStyle("-fx-background-color: #ffc0cb;");
                                }
                            }
                        };
                    }
                };
//        final Callback<DatePicker, DateCell> tableBCellFactoryEnd =
//                new Callback<DatePicker, DateCell>() {
//                    @Override
//                    public DateCell call(final DatePicker datePicker) {
//                        return new DateCell() {
//                            @Override
//                            public void updateItem(LocalDate item, boolean empty) {
//                                super.updateItem(item, empty);
//
//                                if (item.isBefore(
//                                        chartBStartDatePicker.getValue().plusDays(1))
//                                ) {
//                                    setDisable(true);
//                                    setStyle("-fx-background-color: #ffc0cb;");
//                                }
//                                if (item.isAfter(utils.dateToLocalDate(fileOperator.getMaximumDate()))) {
//                                    setDisable((true));
//                                    setStyle("-fx-background-color: #ffc0cb;");
//                                }
//                            }
//                        };
//                    }
//                };
//        final Callback<DatePicker, DateCell> tableCCellFactoryEnd =
//                new Callback<DatePicker, DateCell>() {
//                    @Override
//                    public DateCell call(final DatePicker datePicker) {
//                        return new DateCell() {
//                            @Override
//                            public void updateItem(LocalDate item, boolean empty) {
//                                super.updateItem(item, empty);
//
//                                if (item.isBefore(
//                                        chartCStartDatePicker.getValue().plusDays(1))
//                                ) {
//                                    setDisable(true);
//                                    setStyle("-fx-background-color: #ffc0cb;");
//                                }
//                                if (item.isAfter(utils.dateToLocalDate(fileOperator.getMaximumDate()))) {
//                                    setDisable((true));
//                                    setStyle("-fx-background-color: #ffc0cb;");
//                                }
//                            }
//                        };
//                    }
//                };







//        chartAStartDatePicker.setDayCellFactory(tableACellFactoryStart);
//        chartAEndDatePicker.setDayCellFactory(tableACellFactoryEnd);

//        chartBStartDatePicker.setDayCellFactory(tableBCellFactoryStart);
//        chartBEndDatePicker.setDayCellFactory(tableBCellFactoryEnd);
//
//        chartCStartDatePicker.setDayCellFactory(tableCCellFactoryStart);
//        chartCEndDatePicker.setDayCellFactory(tableCCellFactoryEnd);

//        chartAStartDatePicker.valueProperty().addListener(((observable, oldValue, newValue) -> {
//            if (newValue.isAfter(chartAEndDatePicker.getValue()) || newValue.isEqual(chartAEndDatePicker.getValue()))
//                chartAEndDatePicker.setValue(chartAStartDatePicker.getValue().plusDays(1));
//        }));

//        chartBStartDatePicker.valueProperty().addListener(((observable, oldValue, newValue) -> {
//            if (newValue.isAfter(chartBEndDatePicker.getValue()) || newValue.isEqual(chartBEndDatePicker.getValue()))
//                chartBEndDatePicker.setValue(chartBStartDatePicker.getValue().plusDays(1));
//        }));

//        chartCStartDatePicker.valueProperty().addListener(((observable, oldValue, newValue) -> {
//            if (newValue.isAfter(chartCEndDatePicker.getValue()) || newValue.isEqual(chartCEndDatePicker.getValue()))
//                chartCEndDatePicker.setValue(chartCStartDatePicker.getValue().plusDays(1));
//        }));
//
//        chartAText.textProperty().addListener((observable, oldValue, newValue) -> {
//            //String countryName = tableAText.getText();
//            List<String> countryNamesAdd = fileOperator.searchCountry(newValue);
//            chartACountryList.update(countryNamesAdd);
//            chartAText.requestFocus();
//        });
//
//
//        chartACountryList.update(countryNames);
//
//        chartBText.textProperty().addListener((observable, oldValue, newValue) -> {
//            //String countryName = tableAText.getText();
//            List<String> countryNamesAdd = fileOperator.searchCountry(newValue);
//            chartBCountryList.update(countryNamesAdd);
//            chartBText.requestFocus();
//        });


//        chartBCountryList.update(countryNames);

//        chartCText.textProperty().addListener((observable, oldValue, newValue) -> {
//            //String countryName = tableAText.getText();
//            List<String> countryNamesAdd = fileOperator.searchCountry(newValue);
//            chartCCountryList.update(countryNamesAdd);
//            chartCText.requestFocus();
//        });


//        chartCCountryList.update(countryNames);
    }

    static {
        try {
            fileOperator = new CSVFileOperator("src" + File.separator + "main" + File.separator + "resources" + File.separator + "COVID_Dataset_v1.0.csv");
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            String currentPath = null;
            try {
                currentPath = new java.io.File(".").getCanonicalPath();
            } catch (IOException ex) {
                ex.printStackTrace();
            }
            System.out.println("Current dir:" + currentPath);

            String currentDir = System.getProperty("user.dir");
            System.out.println("Current dir using System:" + currentDir);
        }
    }

    /*
    @FXML
    void tableAFilter(ActionEvent event) {
        String countryName = tableAText.getText();
        List<String> countryNames = fileOperator.searchCountry(countryName);
        tableACountryList.update(countryNames);
    }*/









//    @FXML
//    void doConfirmChartB(ActionEvent event) {
//        ChartSetter.setGraphPropeties(chartB, chartBStartDatePicker, chartBEndDatePicker);
//
//        // save state of checked
//        chartBCountryList.saveState();
//        List<String> countryNames = chartBCountryList.getCheckedItems();
//        Map<String, List<DailyStatistics>> countryTrendMap = fileOperator.getCountryTrendMap(countryNames,
//                utils.localDateToDate(chartBStartDatePicker.getValue()), utils.localDateToDate(chartBEndDatePicker.getValue()));
//        if (countryTrendMap.size() <= 0) {
//            Alert alert = new Alert(Alert.AlertType.ERROR, "Please select at least one country", ButtonType.YES);
//            alert.show();
//            return;
//        }
//        ChartSetter.updateGraph_B(chartB, countryTrendMap);
//    }

    //@FXML
//    void doConfirmChartC(ActionEvent event) {
//        ChartSetter.setGraphPropeties_C(chartC, chartCStartDatePicker, chartCEndDatePicker);
//
//        // save state of checked
//        chartCCountryList.saveState();
//        List<String> countryNames = chartCCountryList.getCheckedItems();
//        Map<String, List<DailyStatistics>> countryTrendMap = fileOperator.getCountryTrendMap_chartC(countryNames,
//                utils.localDateToDate(chartCStartDatePicker.getValue()), utils.localDateToDate(chartCEndDatePicker.getValue()));
//        if (countryTrendMap.size() <= 0) {
//            Alert alert = new Alert(Alert.AlertType.ERROR, "Please select at least one country", ButtonType.YES);
//            alert.show();
//            return;
//        }
//        ChartSetter.updateGraph_C(chartC, countryTrendMap);
//    }

    private static Calendar start;

    static {
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");
        Date startDate = null;
        try {
            startDate = formatter.parse("2020-01-20");
        } catch (ParseException e) {
            e.printStackTrace();
        }
        Date endDate = null;


        start = Calendar.getInstance();
        start.setTime(startDate);

    }


//    @FXML
//    void chartBGo(ActionEvent event) throws InterruptedException, ParseException {
//        ObservableList<XYChart.Series<Number, Number>> chartDataSeriesList = chartB.getData();
//        for (XYChart.Series<Number, Number> series : chartDataSeriesList) {
//            series.getData().clear();
//        }
//    }



    @FXML
    public void saveAsPng() {
        int tabID = mainTabPane.getSelectionModel().getSelectedIndex();
        WritableImage image;
        SnapshotParameters snapshotParameters = new SnapshotParameters();
        snapshotParameters.setTransform(Transform.scale(2, 2));
        if (tabID == 4) {
            LineChart<Number, Number> chart = chartAController.chart;
            image = new WritableImage((int) Math.rint(2 * chart.getWidth()), (int) Math.rint(2 * chart.getHeight()));
            chart.snapshot(snapshotParameters, image);
        } else if (tabID == 5) {
            LineChart<Number, Number> chartB = chartBController.chart;
            image = new WritableImage((int) Math.rint(2 * chartB.getWidth()), (int) Math.rint(2 * chartB.getHeight()));
            chartB.snapshot(snapshotParameters, image);
        } else if (tabID == 6) {
            LineChart<Number, Number> chartC = chartBController.chart;
            image = new WritableImage((int) Math.rint(2 * chartC.getWidth()), (int) Math.rint(2 * chartC.getHeight()));
            chartC.snapshot(snapshotParameters, image);
        } else { // error case
            Alert alert = new Alert(Alert.AlertType.ERROR, "Cannot generate image.", ButtonType.YES);
            alert.show();
            return;
        }


        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Save Image");
        fileChooser.getExtensionFilters().add(new FileChooser.ExtensionFilter("Image (*.png)", "*.png"));
        File file = fileChooser.showSaveDialog(mainTabPane.getScene().getWindow());

        if (file != null) {
            try {
                ImageIO.write(SwingFXUtils.fromFXImage(image, null), "png", file);
            } catch (IOException ex) {
                System.out.println(ex.getMessage());
            }
        }
    }

    /**
     * Task Zero
     * To be triggered by the "Confirmed Cases" button on the Task Zero Tab
     */
    @FXML
    void doConfirmedCases(ActionEvent event) {
        String iDataset = textfieldDataset.getText();
        String iISO = textfieldISO.getText();
        String oReport = DataAnalysis.getConfirmedCases(iDataset, iISO);
        textAreaConsole.setText(oReport);
    }


    /**
     * Task Zero
     * To be triggered by the "Confirmed Deaths" button on the Task Zero Tab
     */
    @FXML
    void doConfirmedDeaths(ActionEvent event) {
        String iDataset = textfieldDataset.getText();
        String iISO = textfieldISO.getText();
        String oReport = DataAnalysis.getConfirmedDeaths(iDataset, iISO);
        textAreaConsole.setText(oReport);
    }


    /**
     * Task Zero
     * To be triggered by the "Rate of Vaccination" button on the Task Zero Tab
     */
    @FXML
    void doRateOfVaccination(ActionEvent event) {
        String iDataset = textfieldDataset.getText();
        String iISO = textfieldISO.getText();
        String oReport = DataAnalysis.getRateOfVaccination(iDataset, iISO);
        textAreaConsole.setText(oReport);
    }


}

